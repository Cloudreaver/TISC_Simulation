#!/usr/bin/env python

# Simulates the output of the GLITC 

from array import array
import numpy as np



def sum_correlate(num_samples,a_dig_waveform,b_dig_waveform,c_dig_waveform,threshold,TISC_sample_length=16,delay_type_flag=0):
   
   speed_of_light = 2.99*10**8
   sample_period = 3.5810**(-10)
   ab_distance = 1.0
   ac_horz_distance = 1.17
   ac_vert_distance = 4.7
   ac_distance = np.sqrt((ac_horz_distance)**2+(ac_vert_distance)**2)

   trigger_flag = 0
   if (delay_type_flag == 1):
      GLITC_delays = np.array([[0,30,42],
                           [0,29,41],
                           [0,29,40],
                           [0,28,38],
                           [0,27,37],
                           [0,27,36],
                           [0,26,35],
                           [0,25,34],
                           [0,25,33],
                           [0,24,32],
                           [0,23,31],
                           [0,23,30],
                           [0,22,29],
                           [0,21,27],
                           [0,20,26],
                           [0,20,25],
                           [0,19,24],
                           [0,18,23],
                           [0,18,22],
                           [0,17,21],
                           [0,17,20],
                           [0,16,20],
                           [0,16,19],
                           [0,15,18],
                           [0,15,17],
                           [0,14,16],
                           [0,13,15],
                           [0,13,14],
                           [0,12,13],
                           [0,12,12],
                           [0,11,11],
                           [0,10,10],
                           [0,9,9],
                           [0,8,8],
                           [0,8,7],
                           [0,8,6],
                           [0,7,5],
                           [0,6,4],
                           [0,6,3],
                           [0,5,3],
                           [0,5,2],
                           [0,4,1],
                           [0,0,0],
                           [16,19,15],
                           [16,18,14],
                           [16,18,13],
                           [16,17,12],
                           [16,17,11],
                           [16,16,11],
                           [16,15,10],
                           [16,15,9],
                           [16,14,8],
                           [16,14,7],
                           [16,13,12],
                           [16,12,5]])
   
###############################################
# Do Sum correlation
###############################################

   prev_sum = 0
   this_sum = 0
   total_sum = 0
   max_total_sum = 0
   add_AB = [0] * TISC_sample_length
   add_ABC = [0] * TISC_sample_length
   best_add_ABC = [0] * TISC_sample_length
   best_b_delay = 0
   best_c_delay = 0
   best_chunk = 0
   b_lower_index_limit = 0
   c_lower_index_limit = 0
   trigger_flag = 0
   if (delay_type_flagg == 1):
      square_sum_ABC = np.zeros(len(GLITC_delays))
      previous_square_sum = np.zeros(len(GLITC_delays))

   if (delay_type_flag == 1):
      for chunk in range(0,2):
         previous_square_sum = square_sum_ABC

         for i in range(0,len(GLITC_delays)):
            a_start_pos = chunk*TISC_sample_length +GLITC_delays[i][0]
            b_start_pos = chunk*TISC_sample_length + GLITC_delays[i][1]
            c_start_pos = chunk*TISC_sample_length + GLITC_delays[i][2]
            add_AB = np.add(a_dig_waveform[a_start_pos:a_start_pos+TISC_sample_length],b_dig_waveform[b_start_pos:b_start_pos+TISC_sample_length])
            add_ABC = np.add(add_AB,c_dig_waveform[c_start_pos:c_start_pos+TISC_sample_length])
            square_ABC = add_ABC**2
            square_sum_ABC[i] = np.sum(square_ABC)

      # Compare the sums
      total_sum = np.add(square_sum_ABC,previous_square_sum)
      max_total_sum = np.max(total_sum)
      best_delays = GLITC_delays[np.argmax(total_sum)]

      ab_theta = np.arcsin((speed_of_light*best_delays[1]*sample_period)/ab_distance)
      ac_theta = np.arctan(ac_vert_distance/ac_horz_distance)-np.pi/2+np.arcsin((speed_of_light*best_delays[2]*sample_period)/ac_distance)
      ab_theta *= 180/np.pi
      ac_theta*= 180/np.pi

      print best_delays
      print ab_theta
      print ac_theta
   else:

      #Set the lower index limit of Ch B/C
      for chunk in range(0,(num_samples/TISC_sample_length)-1):
         if ((TISC_sample_length*(chunk-2)) < 0):
            b_lower_index_limit = 0
            c_lower_index_limit = 0
         else:
            b_lower_index_limit = TISC_sample_length*(chunk-2)
            c_lower_index_limit = TISC_sample_length*(chunk-2)
   
      # Shift Ch B/C around
         for b in range(b_lower_index_limit,(TISC_sample_length*(chunk+1))+1):
            for c in range(c_lower_index_limit,(TISC_sample_length*(chunk+1))+1):
               this_sum = 0
	    #print "delays: "+str(chunk*TISC_sample_length)+':'+str((chunk*TISC_sample_length)+TISC_sample_length-1)+'\t'+str(b)+':'+str(TISC_sample_length+b-1)+'\t'+str(c)+':'+str(TISC_sample_length+c-1)
               add_AB = np.add(a_dig_waveform[chunk*TISC_sample_length:(chunk*TISC_sample_length)+TISC_sample_length],b_dig_waveform[b:TISC_sample_length+b])
               add_ABC = np.add(add_AB,c_dig_waveform[c:TISC_sample_length+c])
               #print len(add_AB)
            # Now do the sum
               for i in range(0,TISC_sample_length-1):
                  this_sum = add_ABC[i]**2
                  total_sum = prev_sum + this_sum
                  if (total_sum > max_total_sum):
                     max_total_sum = total_sum
                     max_this_sum = this_sum
                     if (this_sum > prev_sum):
                     #print add_ABC
                     #print str(this_sum)+'\t'+str(prev_sum)
                     #print "Saving delays"
                        best_chunk = chunk*TISC_sample_length
                        best_b_delay = b-best_chunk
                        best_c_delay = c-best_chunk
                        best_add_ABC = add_ABC
            #print "max_total_sum: " + str(max_total_sum)
            #print str(chunk)+'\t'+str(best_b_delay)+'\t'+str(best_c_delay)
         
            #Close c loop
         #Close b loop
      prev_sum=max_this_sum

   #print max_total_sum
   if(max_total_sum > threshold):
      trigger_flag = 1
      #print "Event passes"
   #print "Threshold: " + str(threshold)
   #print "max_total_sum: " + str(max_total_sum)
   #print "A Chunk: " + str(best_chunk)
   #print "B Delay: " + str(best_b_delay)#+'\t'+str(b_input_delay-best_b_delay)
   #print "C Delay: " + str(best_c_delay)#+'\t'+str(c_input_delay-best_c_delay)
   #print "\n\n"
   return trigger_flag


if __name__ == '__main__':
   import numpy as np
   threshold = 300
   num_samples = 128
   a_dig_waveform = np.zeros(num_samples)
   a_dig_waveform[10] = 3.5
   a_dig_waveform[11] = -3.5
   a_dig_waveform[12] = 2.5
   a_dig_waveform[13] = -2.5
   TISC_sample_length = 16
   delay_type_flag = 1

   #print num_samples
   #print a_dig_waveform
   passed_flag = sum_correlate(num_samples,a_dig_waveform,a_dig_waveform,a_dig_waveform,threshold,TISC_sample_length=TISC_sample_length,delay_type_flag=delay_type_flag)
   print passed_flag
