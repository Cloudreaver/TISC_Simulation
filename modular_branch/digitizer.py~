#!/usr/bin/env python

# Simulates the RITC output 

import random
import numpy as np



def digitize(input_array,num_samples,upsample,num_bits,noise_mean,noise_rms,digitization_factor=1):
   
   noise_rms *= digitization_factor
         
   # Fill numpy arrays with zeros
   dig_waveform = np.zeros(num_samples)
   
   # Convert to 3 bit values
   for index in range(0,num_samples):
      for bit_index in range(0,2**(num_bits-1)):
         if (upsample > 1):
            downsample_random = random.randrange(0,upsample-1)
         else:
            downsample_random = 0
         if input_array[(index*upsample)+downsample_random] > (bit_index)*(noise_rms)+noise_mean: 
            dig_waveform[index] = bit_index+0.5
         elif input_array[(index*upsample)+downsample_random] < ((-bit_index)*(noise_rms)+noise_mean): 
            dig_waveform[index] = -bit_index-0.5
      
         
   return dig_waveform

if __name__ == '__main__':
   import numpy as np
   from noise import generate_noise

   num_samples = 48
   upsample = 1
   num_bits = 3
   noise_mean = 450
   noise_sigma = 25
   digitization_factor = 1

   num_upsamples = num_samples*upsample
   sample_noise = np.zeros(num_upsamples)
   dig_waveform = np.zeros(num_samples)

   sample_noise = generate_noise(num_upsamples,noise_mean,noise_sigma,1)
   noise_rms = np.sqrt(np.mean((sample_noise-noise_mean)**2))
   sample_noise[4] = noise_mean +(noise_rms*10)

   
   dig_waveform = digitize(sample_noise,num_samples,upsample,num_bits,noise_mean,noise_rms,digitization_factor)

   print dig_waveform
   print noise_sigma
   print noise_rms
